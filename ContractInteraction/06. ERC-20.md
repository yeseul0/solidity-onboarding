**Fungible Token**은 대체 가능한 특성을 가진 디지털 자산으로, 각 토큰이 동일한 가치를 지니고 서로 교환 가능하다. 

실물 화폐와 유사한 개념으로, 예를 들어 1달러 지폐는 다른 1달러 지폐와 동일한 가치를 가지며 대체 가능하다. 같은 Fungible-Token끼리는 같은 가치를 같기 때문에 구분할 필요 없다. 

**ERC-20**은 이더리움 블록체인에서 **Fungible Token**을 위한 **표준 프로토콜**이다. ERC-20 표준은 토큰의 **전송**, **잔액 조회**, **총 공급량 확인** 등의 기본적인 기능을 정의한다. 

## ERC20 표준 인터페이스

```solidity
interface IERC20 {
    function totalSupply() external view returns (uint256); // 총 공급량 확인
    function balanceOf(address account) external view returns (uint256); // 특정 계정의 잔액 조회
    function transfer(address recipient, uint256 amount) external returns (bool); // 토큰 전송
    function allowance(address owner, address spender) external view returns (uint256); // 허용된 전송 한도 조회
    function approve(address spender, uint256 amount) external returns (bool); // 전송 권한 부여
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool); // 권한을 사용한 토큰 전송

		event Transfer(address indexed from, address indexed to, uint256 value); // 토큰 전송 이벤트
		event Approval(address indexed owner, address indexed spender, uint256 value); // 권한 부여 이벤트

}
```

## ERC20 구현

```solidity
contract ERC20 is IERC20 {

    uint256 public totalSupply;
    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;
    string public name;
    string public symbol;
    uint8 public decimals;

    constructor(string memory _name, string memory _symbol, uint8 _decimals) {
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
    }

    function transfer(address recipient, uint256 amount) external returns (bool) {
        balanceOf[msg.sender] -= amount;
        balanceOf[recipient] += amount;
        emit Transfer(msg.sender, recipient, amount);
        return true;
    }

    function approve(address spender, uint256 amount) external returns (bool) {
        allowance[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool) {
        allowance[sender][msg.sender] -= amount;
        balanceOf[sender] -= amount;
        balanceOf[recipient] += amount;
        emit Transfer(sender, recipient, amount);
        return true;
    }

    function _mint(address to, uint256 amount) internal {
        balanceOf[to] += amount;
        totalSupply += amount;
        emit Transfer(address(0), to, amount);
    }

    function _burn(address from, uint256 amount) internal {
        balanceOf[from] -= amount;
        totalSupply -= amount;
        emit Transfer(from, address(0), amount);
    }

    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }

    function burn(address from, uint256 amount) external {
        _burn(from, amount);
    }
}
```

### 상태변수

```solidity
		uint256 public totalSupply;
    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;
    string public name;
    string public symbol;
    uint8 public decimals;
```

`totalSupply` 현재 발행된 총 토큰 수 (해당 토큰의 전체 공급량)

`balanceOf` 각 주소의 토큰 잔액을 저장하는 매핑

`allowance` 특정 주소가 다른 주소에게 허용한 토큰 전송 한도를 저장하는 매핑(승인된 전송 권한)

`name` 토큰 이름

`symbol` 토큰 심볼(예: ETH, BTC, LINK)

`decimals` 소수점 자리수(토큰 단위의 정밀도)

### 생성자

```solidity
constructor(string memory _name, string memory _symbol, uint8 _decimals) {
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
    }
```

토큰의 이름, 심볼, 소수점 자리수를 초기화하며 생성

사용 예시 : ERC20("MyToken", "MTK", 18);

### 주요 함수

### transfer()

```solidity
function transfer(address recipient, uint256 amount) external returns (bool) {
        balanceOf[msg.sender] -= amount;
        balanceOf[recipient] += amount;
        emit Transfer(msg.sender, recipient, amount);
        return true;
    }
```

토큰 전송

- `recipient`: 토큰을 받을 주소.
- `amount`: 전송할 토큰 수량.

호출자의 잔액에서 `amount`를 차감하고, 수신자의 잔액에 추가

`Transfer` 이벤트를 발생

### approve()

```solidity
 function approve(address spender, uint256 amount) external returns (bool) {
        allowance[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }
```

다른 주소에게 (내 주소에 있는) 토큰을 전송시킬 수 있는 권한을 부여한다. 

- `spender`: 권한을 부여받을 주소.
- `amount`: 허용할 토큰 수량.

`allowance` 매핑에 권한을 저장

`Approval` 이벤트를 발생

### tranferFrom()

```solidity
function transferFrom(address sender, address recipient, uint256 amount) external returns (bool) {
        allowance[sender][msg.sender] -= amount;
        balanceOf[sender] -= amount;
        balanceOf[recipient] += amount;
        emit Transfer(sender, recipient, amount);
        return true;
    }
```

승인된 권한(approve 함수 선행되어야함)을 사용하여 다른 계정에서 토큰을 전송

- `sender`: 토큰을 보내는 주소.
- `recipient`: 토큰을 받는 주소.
- `amount`: 전송할 토큰 수량.

`allowance`를 업데이트하고, 잔액을 조정

`Transfer` 이벤트 발생

### _mint() (internal)

```solidity
function _mint(address to, uint256 amount) internal {
        balanceOf[to] += amount;
        totalSupply += amount;
        emit Transfer(address(0), to, amount);
    }
```

새로운 토큰을 특정 주소에 발행

- `to`: 토큰을 받을 주소.
- `amount`: 생성할 토큰 수량.

`totalSupply`를 증가시키고, 잔액을 업데이트

`Transfer` 이벤트를 발생(민트 시 `from`은 `address(0)`)

> 주소가 0인건, 아무도 쓰지 않는 지갑을 의미.. 
비활성화 된 주소로, 어떤 address 변수의 초기상태나 소각 목적지, 발행 출발지로 많이 쓰임 

### _burn() (internal)

```solidity
function _burn(address from, uint256 amount) internal {
        balanceOf[from] -= amount;
        totalSupply -= amount;
        emit Transfer(from, address(0), amount);
    }
```

특정 주소의 토큰을 소각

- `from`: 소각할 토큰이 있는 주소.
- `amount`: 소각할 토큰 수량.

`totalSupply`를 감소시키고, 잔액을 업데이트

`Transfer` 이벤트를 발생(소각 시 `to`는 `address(0)`)

### mint() (external)

```solidity
function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }
```

### burn (external)

```solidity
function burn(address from, uint256 amount) external {
        _burn(from, amount);
    }
```

---

누구든지 `mint`를 호출하여 원하는 만큼 토큰을 발행할 수 있다거나

누구든지 `burn` 을 호출하여 다른 사람의 토큰을 소각할 수 있으면 안 됨. 

그래서 보통 관리자만 호출할 수 있게 한다던지, 토큰 설계자 나름의 조건 검사를 추가하기 위해
`mint`, `burn` 함수는 외부 호출용을 따로 빼서  modifier로 관리자만 호출할 수 있게 하는 등의 임의의 조건을 달 수 있다. OpenZeppelin의 `Ownable` modifier를 임포트해서 쓰기도 함. (현재 위에는 아무것도 안한 상태의 코드다)