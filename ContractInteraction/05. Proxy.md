# Upgradable Contract (ProxyAdmin patterh)

Upgradable Contract는  스마트 컨트랙트의 로직을 변경하거나 확장할 수 있는 구조를 가진 컨트랙트를 말한다. 기본적으로 블록체인에 배포된 스마트 컨트랙트는 수정이 불가능하지만, upgradable contract는 기존 데이터를 그대로 유지하면서 새로운 로직을 적용할 수 있는 패턴을 사용한다. 
Proxy 컨트랙트가 사용자가 호출하는 고정된 주소를 가진 컨트랙트이며, delegatecall을 통해 실제 로직은 다른 컨트랙트(Logic Contract)를 호출한다. 호출할 컨트랙트(logic contract)의 주소 상태를 바꿈으로써 사용자는 같은 Proxy 컨트랙트를 호출하면서도 새로운 로직을 적용할 수 있게 된다. 

```bash
사용자 → Proxy → LogicV1 (기본 로직 실행)
사용자 → Proxy → LogicV2 (새로운 로직 실행, 기존 데이터 유지)
```

아래 예제에서는 ProxyAdmin 컨트랙트가 Proxy가 참조하는 구현 컨트랙트 주소를 업그레이드 할 수 있는 권한을 가지며 관리하는 역할을 한다. 

## StorageSlot library
```soldity
library StorageSlot {
    struct AddressSlot {
        address value; //슬롯에 저장된 값(주소 형태)
    }

    function getAddressSlot(bytes32 slot)
        internal
        pure
        returns (AddressSlot storage r)
    {
        assembly {
            r.slot := slot //특정 슬롯 반환
        }
    }
}
```

- `getAddressSlot()` : 특정 슬롯(`bytes32 slot`)을 지정하면 그 슬롯에 저장된 데이터를 반환하는 함수
- `struct AddressSlot` : address변수를 value라는 이름으로 갖고 있음

### 사용 예시!! 
```solidity
bytes32 private constant ADMIN_SLOT = bytes32(uint256(keccak256("eip1967.proxy.admin"))-1);

function _getAdmin() private view returns (address) {
    return StorageSlot.getAddressSlot(ADMIN_SLOT).value;
}
```
1. `ADMIN_SLOT` 슬롯정의  
`keccak256("eip1967.proxy.admin")`:
"eip1967.proxy.admin" 문자열의 해시값을 계산한다. (특정 슬롯을 고유하게 식별하기 위해)  
`- 1`:
EVM 저장소 슬롯 충돌을 방지하기 위해 해시값에서 1을 빼서 사용
2. `_getAdmin()` 슬롯 데이터 읽기
`StorageSlot.getAddressSlot(ADMIN_SLOT)`: `StorageSlot` 라이브러리의 `getAddressSlot()`함수 호출 
`ADMIN_SLOT`에 저장된 데이터를 가져오는데, 반환 데이터는 `AddressSlot` 구조체. 
그 구조체의 `value` 값에 접근하여 결과적으로 슬롯에 저장된 어떠한 주소를 반환하는 꼴이다. 


## Proxy(EIP-1967 준수)
```solidity
contract Proxy {

    bytes32 private constant IMPLEMENTATION_SLOT =
        bytes32(uint256(keccak256("eip1967.proxy.implementation")) - 1);

    bytes32 private constant ADMIN_SLOT =
        bytes32(uint256(keccak256("eip1967.proxy.admin")) - 1);

    constructor() {
        _setAdmin(msg.sender);
    }

    modifier ifAdmin() {
        if (msg.sender == _getAdmin()) {
            _;
        } else {
            _fallback();
        }
    }

    function _getAdmin() private view returns (address) {
        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;
    }

    function _setAdmin(address _admin) private {
        require(_admin != address(0), "admin = zero address");
        StorageSlot.getAddressSlot(ADMIN_SLOT).value = _admin;
    }

    function _getImplementation() private view returns (address) {
        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;
    }

    function _setImplementation(address _implementation) private {
        require(
            _implementation.code.length > 0, "implementation is not contract"
        );
        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = _implementation;
    }

    function changeAdmin(address _admin) external ifAdmin {
        _setAdmin(_admin);
    }

    function upgradeTo(address _implementation) external ifAdmin {
        _setImplementation(_implementation);
    }

    function admin() external ifAdmin returns (address) {
        return _getAdmin();
    }

    function implementation() external ifAdmin returns (address) {
        return _getImplementation();
    }

    function _delegate(address _implementation) internal virtual {
        assembly {
           
            calldatacopy(0, 0, calldatasize())

            let result :=
                delegatecall(gas(), _implementation, 0, calldatasize(), 0, 0)

            returndatacopy(0, 0, returndatasize())

            switch result
            case 0 {
                revert(0, returndatasize())
            }
            default {
                return(0, returndatasize())
            }
        }
    }

    function _fallback() private {
        _delegate(_getImplementation());
    }

    fallback() external payable {
        _fallback();
    }

    receive() external payable {
        _fallback();
    }
}
```

`IMPLEMENTATION_SLOT`: Proxy가 연결된 Implementation 컨트랙트 주소를 저장하는 슬롯  
`ADMIN_SLOT`: Proxy의 관리자 주소를 저장하는 슬롯  
=> 다른 컨트랙트와 충돌을 방지하기 위해 저장소 슬롯을 명확히 지정하는 것.    
> 업그레이드 가능한 Proxy 컨트랙트에서는 Proxy 컨트랙트와 Implementation 컨트랙트가 같은 저장소를 공유한다.
이때, Proxy와 Implementation의 상태 변수 순서가 다르면 저장소 충돌이 발생할 수 있었음을 기억하자 
EIP-1967 표준은 Proxy 컨트랙트에서 관리자 주소와 Implementation 주소를 고정된 슬롯에 저장하도록 규정하고 있다.  




- `constructor()` : 배포한 사람(msg.sender)을 **관리자(admin)** 로 설정  
- `ifAdmin()` : **관리자만** 특정 함수 실행 가능하도록 제한  
- `_getAdmin()` : `ADMIN_SLOT`에 저장된 관리자 주소를 가져옴  
- `_setAdmin()` : admin 주소를 설정  
- `_getImplementation()` : `IMPLEMENTATION_SLOT`에 저장된 Implementation 컨트랙트 주소를 가져옴(Proxy가 연결된 실제 기능 컨트랙트의 주소를 반환)
- `_setImplementation()` : Implementation 컨트랙트 주소를 설정
- `changeAdmin()` : (관리자만 실행할 수 있는) 새로운 관리자 주소를 설정 함수
- `upgradeTo()` : (관리자만 실행할 수 있는) Proxy가 연결된 Implementation 컨트랙트를 새로운 컨트랙트로 변경하는 함수
- `admin()` : 관리자 주소 반환
- `implementation()` : 컨트랙트 주소 반환
- `_delegate` : 사용자의 요청을 Implementation 컨트랙트로 전달
> Assembly는 Solidity의 저수준 언어로, 이더리움 가상 머신(EVM)의 명령어를 직접 작성할 수 있다.   
```solidity
assembly {
           
            calldatacopy(0, 0, calldatasize())

            let result :=
                delegatecall(gas(), _implementation, 0, calldatasize(), 0, 0)

            returndatacopy(0, 0, returndatasize())

            switch result
            case 0 {
                revert(0, returndatasize())
            }
            default {
                return(0, returndatasize())
            }
        }
```
이부분을 좀 더 자세히 보자
### `calldatacopy(0, 0, calldatasize())`
사용자가 Proxy 컨트랙트에 보낸 **요청 데이터(call data)** 를 복사한다.  
- `calldatasize()`: 요청 데이터의 크기를 반환한다.
- `calldatacopy(destOffset, srcOffset, length)`:
    - `destOffset`: 데이터를 저장할 메모리 위치 (여기서는 `0`).
    - `srcOffset`: 요청 데이터의 시작 위치 (여기서는 `0`).
    - `length`: 복사할 데이터의 크기 (`calldatasize()`).

### `delegatecall(gas(), _implementation, 0, calldatasize(), 0, 0)`
요청을 Implementation 컨트랙트로 전달하고, 해당 컨트랙트의 코드를 Proxy 저장소를 사용하여 실행시킨다. ( Proxy 컨트랙트의 상태를 변경하거나 읽을 수 있음) 

- `delegatecall(gas, target, inOffset, inSize, outOffset, outSize)`:
    - `gas()`: 실행에 사용할 가스 양.
    - `target`: 호출할 컨트랙트 주소 (`_implementation`).
    - `inOffset`: 입력 데이터가 저장된 메모리 위치 (여기서는 `0`).
    - `inSize`: 입력 데이터의 크기 (`calldatasize()`).
    - `outOffset`: 반환 데이터를 저장할 메모리 위치 (여기서는 `0`).
    - `outSize`: 반환 데이터의 크기 (여기서는 `0`).  
      
`delegatecall`의 성공 여부를 `result` 변수에 저장 

### `returndatacopy(0, 0, returndatasize())` 
Implementation 컨트랙트에서 반환된 데이터를 복사  
- `returndatasize()`: 반환 데이터의 크기를 반환한다.
- `returndatacopy(destOffset, srcOffset, length)`:
    - `destOffset`: 데이터를 저장할 메모리 위치 (여기서는 `0`).
    - `srcOffset`: 반환 데이터의 시작 위치 (여기서는 `0`).
    - `length`: 복사할 데이터의 크기 (`returndatasize()`).

### `switch result` 
- `case 0`: `result`가 `0`인 경우 → `delegatecall`이 실패했음을 의미.
    - `revert(0, returndatasize())`: 반환 데이터를 사용해 트랜잭션을 되돌린다.
- `default`: `result`가 `1`인 경우 → `delegatecall`이 성공했음을 의미.
    - `return(0, returndatasize())`: 반환 데이터를 사용자에게 전달한다. 
> 전체 흐름 정리  
사용자가 Proxy 컨트랙트에 요청을 보내오면,  
Proxy는 요청데이터를 calldata -> memory로 복사하고 
Implementation 컨트랙트에 요청을 전달(delegatecall)한다.  
Implementation 컨트랙트가 실행을 완료하고 결과를 Proxy로 다시 반환!!  

> **delegatecall**은 입력 데이터와 출력 데이터를 모두 메모리를 통해 처리하는 파라미터 구조를 갖고있지만, 내부적으로는 memory에 있는 입력 내용을 calldata로 변환하여 다른 컨트랙트 함수를 호출하고, 반환값을 returndata로 받아 다시 memory에 저장하는 흐름이다. 
---
## ProxyAdmin
```solidity
contract ProxyAdmin {
    address public owner;

    constructor() {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, "not owner");
        _;
    }

    function getProxyAdmin(address proxy) external view returns (address) {
        (bool ok, bytes memory res) =
            proxy.staticcall(abi.encodeCall(Proxy.admin, ()));
        require(ok, "call failed");
        return abi.decode(res, (address));
    }


    function getProxyImplementation(address proxy)
        external
        view
        returns (address)
    {
        (bool ok, bytes memory res) =
            proxy.staticcall(abi.encodeCall(Proxy.implementation, ()));
        require(ok, "call failed");
        return abi.decode(res, (address));
    }

    function changeProxyAdmin(address payable proxy, address admin)
        external
        onlyOwner
    {
        Proxy(proxy).changeAdmin(admin);
    }

    function upgrade(address payable proxy, address implementation)
        external
        onlyOwner
    {
        Proxy(proxy).upgradeTo(implementation);
    }
}
```
이 컨트랙트는 Proxy 컨트랙트를 관리하기 위한 인터페이스 역할을 하며, Proxy 컨트랙트의 Admin, Implementation 주소를 조회하거나 변경하고, Proxy 컨트랙트를 업그레이드할 수 있는 기능을 제공한다. 

- `owner` : ProxyAdmin 컨트랙트의 소유자 주소를 저장
- `constructor()` : 이 컨트랙트를 배포한 주소를 owner 변수에 저장
- `onlyOwner()` : 컨트랙트의 소유자만 호출할 수 있도록 제한하는 modifier
- `getProxyAdmin()` : Proxy 컨트랙트의 `admin()` 함수를 호출하여 Admin 주소를 반환 (staticcall은 상태를 변경하지 않는 호출에 사용됨)
- `getProxyImplementation()` : Proxy 컨트랙트의 `implementation()` 함수를 호출하여 Implementation 주소를 반환받음 
- `changeProxyAdmin` : Proxy 컨트랙트의 `changeAdmin()` 함수를 호출하여 새로운 Admin 주소를 설정(참고로 `Proxy(proxy).changeAdmin`는 proxy 주소를 Proxy 컨트랙트 타입으로 캐스팅하여 `changeAdmin`이라는 함수를 호출한 것)
- `upgrade()` : Proxy 컨트랙트의 `upgradeTo()` 함수를 호출하여 새로운 Implementation 주소를 설정

---
## 전체코드
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

contract CounterV1 {
    uint256 public count;

    function inc() external {
        count += 1;
    }
}

contract CounterV2 {
    uint256 public count;

    function inc() external {
        count += 1;
    }

    function dec() external {
        count -= 1;
    }
}

contract Proxy {

    bytes32 private constant IMPLEMENTATION_SLOT =
        bytes32(uint256(keccak256("eip1967.proxy.implementation")) - 1);
    
    bytes32 private constant ADMIN_SLOT =
        bytes32(uint256(keccak256("eip1967.proxy.admin")) - 1);

    constructor() {
        _setAdmin(msg.sender);
    }

    modifier ifAdmin() {
        if (msg.sender == _getAdmin()) {
            _;
        } else {
            _fallback();
        }
    }

    function _getAdmin() private view returns (address) {
        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;
    }

    function _setAdmin(address _admin) private {
        require(_admin != address(0), "admin = zero address");
        StorageSlot.getAddressSlot(ADMIN_SLOT).value = _admin;
    }

    function _getImplementation() private view returns (address) {
        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;
    }

    function _setImplementation(address _implementation) private {
        require(
            _implementation.code.length > 0, "implementation is not contract"
        );
        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = _implementation;
    }

    function changeAdmin(address _admin) external ifAdmin {
        _setAdmin(_admin);
    }

    function upgradeTo(address _implementation) external ifAdmin {
        _setImplementation(_implementation);
    }

    function admin() external ifAdmin returns (address) {
        return _getAdmin();
    }

    function implementation() external ifAdmin returns (address) {
        return _getImplementation();
    }

    function _delegate(address _implementation) internal virtual {
        assembly {
           
            calldatacopy(0, 0, calldatasize())

            let result :=
                delegatecall(gas(), _implementation, 0, calldatasize(), 0, 0)

            returndatacopy(0, 0, returndatasize())

            switch result
            case 0 {
                revert(0, returndatasize())
            }
            default {
                return(0, returndatasize())
            }
        }
    }

    function _fallback() private {
        _delegate(_getImplementation());
    }

    fallback() external payable {
        _fallback();
    }

    receive() external payable {
        _fallback();
    }
}

contract ProxyAdmin {
    address public owner;

    constructor() {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, "not owner");
        _;
    }

    function getProxyAdmin(address proxy) external view returns (address) {
        (bool ok, bytes memory res) =
            proxy.staticcall(abi.encodeCall(Proxy.admin, ()));
        require(ok, "call failed");
        return abi.decode(res, (address));
    }


    function getProxyImplementation(address proxy)
        external
        view
        returns (address)
    {
        (bool ok, bytes memory res) =
            proxy.staticcall(abi.encodeCall(Proxy.implementation, ()));
        require(ok, "call failed");
        return abi.decode(res, (address));
    }

    function changeProxyAdmin(address payable proxy, address admin)
        external
        onlyOwner
    {
        Proxy(proxy).changeAdmin(admin);
    }

    function upgrade(address payable proxy, address implementation)
        external
        onlyOwner
    {
        Proxy(proxy).upgradeTo(implementation);
    }
}

library StorageSlot {
    struct AddressSlot {
        address value;
    }

    function getAddressSlot(bytes32 slot)
        internal
        pure
        returns (AddressSlot storage r)
    {
        assembly {
            r.slot := slot
        }
    }
}

```

### 실습 순서
1. Proxy, ProxyAdmin 컨트랙트 배포  
2. Proxy 컨트랙트 upgradeTo에 CounterV1 컨트랙트 주소(logig contract) 입력  
3. Implementation을 누르면 log의 decoded output을 통해 logic contract 주소가 ProxyContract에 반영돼 있는 것을 확인할 수 있다.  
4. Proxy 컨트랙트의 changeAdmin에 ProxyAdmin 컨트랙트 address를 입력  
5. ProxyAdmin 컨트랙트에 getProxyAdmin, getProxyImplementation에 Proxy 컨트랙트의 주소를 입력하여 결과를 확인  
6. ProxyAdmin에서 upgrade에 CounterV2 컨트랙트 주소를 넣고 3번과 같이 implementation 로그 확인하기 (Proxy의 admin이 ProxyAdmin 컨트랙트로  4번에서 바뀌었기 때문에 delegatecall 대상 컨트랙트 주소는 ProxyAdmin 컨트랙트를 통해서 바꿔줘야함)