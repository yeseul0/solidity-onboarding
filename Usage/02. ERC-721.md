# ERC-721 (Non-Fungible-Token)
ERC721은 **NFT(Non-Fungible Token)**을 위한 표준으로, **각 토큰이 고유하고 서로 교환할 수 없는 특징**을 가지고 있다. ERC20과 달리 모든 토큰이 동일하지 않고, 각각의 토큰이 tokenID로 구별되며 독립적인 고유성을 가지고 있다. 예를 들어, ERC20은 "1 ETH = 1 ETH"처럼 모든 토큰이 동일하게 취급되지만, ERC721에서는 "그림 A ≠ 그림 B"처럼 각 토큰이 고유한 가치를 지닌다.

이 표준은 **디지털 자산**, **예술품**, **게임 아이템** 등 고유한 소유권을 표현하기 위해 사용되기 쉽다. 각 NFT는 특정 아이템을 나타내며, 소유자는 이를 고유 ID로 관리한다. 예를 들어, "NFT ID #123"은 특정 그림이나 아이템을 나타내며, 이 ID를 가진 주소의 주인이 해당 NFT의 소유자인 것이다.

ERC721의 토큰은 숫자가 아닌 **고유 ID**로 표현되며, 이는 각 NFT가 고유한 자산임을 보장한다. 이러한 특징 때문에 ERC721은 디지털 자산의 소유권을 명확히 하고, 대체 불가능한 아이템을 관리하는 데 적합하다고 할 수 있는 것이다.

## **ERC721 구현**

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

interface IERC165 {
    function supportsInterface(bytes4 interfaceID)
        external
        view
        returns (bool);
}

interface IERC721 is IERC165 {
    function balanceOf(address owner) external view returns (uint256 balance);
    function ownerOf(uint256 tokenId) external view returns (address owner);
    function safeTransferFrom(address from, address to, uint256 tokenId)
        external;
    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId,
        bytes calldata data
    ) external;
    function transferFrom(address from, address to, uint256 tokenId) external;
    function approve(address to, uint256 tokenId) external;
    function getApproved(uint256 tokenId)
        external
        view
        returns (address operator);
    function setApprovalForAll(address operator, bool _approved) external;
    function isApprovedForAll(address owner, address operator)
        external
        view
        returns (bool);
}

interface IERC721Receiver {
    function onERC721Received(
        address operator,
        address from,
        uint256 tokenId,
        bytes calldata data
    ) external returns (bytes4);
}

contract ERC721 is IERC721 {
    event Transfer(
        address indexed from, address indexed to, uint256 indexed id
    );
    event Approval(
        address indexed owner, address indexed spender, uint256 indexed id
    );
    event ApprovalForAll(
        address indexed owner, address indexed operator, bool approved
    );

    // Mapping from token ID to owner address
    mapping(uint256 => address) internal _ownerOf;

    // Mapping owner address to token count
    mapping(address => uint256) internal _balanceOf;

    // Mapping from token ID to approved address
    mapping(uint256 => address) internal _approvals;

    // Mapping from owner to operator approvals
    mapping(address => mapping(address => bool)) public isApprovedForAll;

    function supportsInterface(bytes4 interfaceId)
        external
        pure
        returns (bool)
    {
        return interfaceId == type(IERC721).interfaceId
            || interfaceId == type(IERC165).interfaceId;
    }

    function ownerOf(uint256 id) external view returns (address owner) {
        owner = _ownerOf[id];
        require(owner != address(0), "token doesn't exist");
    }

    function balanceOf(address owner) external view returns (uint256) {
        require(owner != address(0), "owner = zero address");
        return _balanceOf[owner];
    }

    function setApprovalForAll(address operator, bool approved) external {
        isApprovedForAll[msg.sender][operator] = approved;
        emit ApprovalForAll(msg.sender, operator, approved);
    }

    function approve(address spender, uint256 id) external {
        address owner = _ownerOf[id];
        require(
            msg.sender == owner || isApprovedForAll[owner][msg.sender],
            "not authorized"
        );

        _approvals[id] = spender;

        emit Approval(owner, spender, id);
    }

    function getApproved(uint256 id) external view returns (address) {
        require(_ownerOf[id] != address(0), "token doesn't exist");
        return _approvals[id];
    }

    function _isApprovedOrOwner(address owner, address spender, uint256 id)
        internal
        view
        returns (bool)
    {
        return (
            spender == owner || isApprovedForAll[owner][spender]
                || spender == _approvals[id]
        );
    }

    function transferFrom(address from, address to, uint256 id) public {
        require(from == _ownerOf[id], "from != owner");
        require(to != address(0), "transfer to zero address");

        require(_isApprovedOrOwner(from, msg.sender, id), "not authorized");

        _balanceOf[from]--;
        _balanceOf[to]++;
        _ownerOf[id] = to;

        delete _approvals[id];

        emit Transfer(from, to, id);
    }

    function safeTransferFrom(address from, address to, uint256 id) external {
        transferFrom(from, to, id);

        require(
            to.code.length == 0
                || IERC721Receiver(to).onERC721Received(msg.sender, from, id, "")
                    == IERC721Receiver.onERC721Received.selector,
            "unsafe recipient"
        );
    }

    function safeTransferFrom(
        address from,
        address to,
        uint256 id,
        bytes calldata data
    ) external {
        transferFrom(from, to, id);

        require(
            to.code.length == 0
                || IERC721Receiver(to).onERC721Received(msg.sender, from, id, data)
                    == IERC721Receiver.onERC721Received.selector,
            "unsafe recipient"
        );
    }

    function _mint(address to, uint256 id) internal {
        require(to != address(0), "mint to zero address");
        require(_ownerOf[id] == address(0), "already minted");

        _balanceOf[to]++;
        _ownerOf[id] = to;

        emit Transfer(address(0), to, id);
    }

    function _burn(uint256 id) internal {
        address owner = _ownerOf[id];
        require(owner != address(0), "not minted");

        _balanceOf[owner] -= 1;

        delete _ownerOf[id];
        delete _approvals[id];

        emit Transfer(owner, address(0), id);
    }
}

contract MyNFT is ERC721 {
    function mint(address to, uint256 id) external {
        _mint(to, id);
    }

    function burn(uint256 id) external {
        require(msg.sender == _ownerOf[id], "not owner");
        _burn(id);
    }
}

```

### IERC165 인터페이스

```solidity
interface IERC165 {
    function supportsInterface(bytes4 interfaceID)
        external
        view
        returns (bool);
}
```

**ERC165 표준 인터페이스**

`supportsInterface` 

특정 인터페이스 ID(`interfaceID`)를 입력받아 컨트랙트가 해당 인터페이스를 지원하는지 여부를 반환

ERC721과 같은 표준은 반드시 **ERC165를 준수**해야 함

### IERC721 인터페이스

```solidity
interface IERC721 is IERC165 {
    function balanceOf(address owner) external view returns (uint256 balance);
    function ownerOf(uint256 tokenId) external view returns (address owner);
    function safeTransferFrom(address from, address to, uint256 tokenId)
        external;
    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId,
        bytes calldata data
    ) external;
    function transferFrom(address from, address to, uint256 tokenId) external;
    function approve(address to, uint256 tokenId) external;
    function getApproved(uint256 tokenId)
        external
        view
        returns (address operator);
    function setApprovalForAll(address operator, bool _approved) external;
    function isApprovedForAll(address owner, address operator)
        external
        view
        returns (bool);
}
```

**ERC721 표준 인터페이스**

`IERC165`를 상속받아 **ERC165 표준**을 준수

소유권 관리

- `balanceOf`: 특정 주소가 소유한 NFT의 개수를 반환
- `ownerOf`: 특정 NFT의 소유자를 반환

전송

- `transferFrom`: NFT를 다른 주소로 전송
- `safeTransferFrom`: 안전한 NFT 전송을 지원하며, 컨트랙트 주소로의 전송 시 수신 가능 여부를 확인

승인

- `approve`: 특정 주소에게 NFT를 전송할 권한을 부여
- `getApproved`: 특정 NFT에 대해 승인된 주소를 반환
- `setApprovalForAll`: 모든 NFT에 대해 특정 주소에게 권한을 부여
- `isApprovedForAll`: 특정 주소가 모든 NFT에 대해 승인되었는지 확인

### IERC721Receiver 인터페이스

```solidity
interface IERC721Receiver {
    function onERC721Received(
        address operator,
        address from,
        uint256 tokenId,
        bytes calldata data
    ) external returns (bytes4);
}
```

**ERC721 표준에서 안전한 전송을 보장**하기 위한 인터페이스

컨트랙트가 NFT를 받을 준비가 되었는지 확인하는 기능

IERC165 → 호환성

IERC721 → NFT 관리

IERC721Receiver → 안전한 전송

---

## ERC721 컨트랙트

### 이벤트 정의

```solidity
		event Transfer(
        address indexed from, address indexed to, uint256 indexed id
    );
    event Approval(
        address indexed owner, address indexed spender, uint256 indexed id
    );
    event ApprovalForAll(
        address indexed owner, address indexed operator, bool approved
    );
```

1. **`Transfer`**
    - NFT가 전송될 때 발생
    - `from`: 이전 소유자 주소
    - `to`: 새로운 소유자 주소
    - `id`: 전송된 NFT ID
2. **`Approval`**
    - 특정 주소가 NFT를 전송할 권한을 부여받았을 때 발생
    - `owner`: NFT 소유자
    - `spender`: 권한을 부여받은 주소
    - `id`: 승인된 NFT ID
3. **`ApprovalForAll`**
    - 특정 주소가 모든 NFT에 대해 권한을 부여받았을 때 발생
    - `owner`: NFT 소유자
    - `operator`: 권한을 부여받은 주소
    - `approved`: 승인 여부 (`true` 또는 `false`)

### 상태변수

```solidity
// Mapping from token ID to owner address
    mapping(uint256 => address) internal _ownerOf;

    // Mapping owner address to token count
    mapping(address => uint256) internal _balanceOf;

    // Mapping from token ID to approved address
    mapping(uint256 => address) internal _approvals;

    // Mapping from owner to operator approvals
    mapping(address => mapping(address => bool)) public isApprovedForAll;
```

1. **`_ownerOf`**:
    - 각 NFT ID에 대한 소유자 주소를 저장
    - 예: `NFT ID 1`의 소유자가 `address A`라면, `_ownerOf[1] = address A`
2. **`_balanceOf`**:
    - 각 주소가 소유한 NFT 개수를 저장
    - 예: `address A`가 3개의 NFT를 소유하면, `_balanceOf[address A] = 3`
3. **`_approvals`**:
    - 각 NFT ID에 대해 승인된 주소를 저장
    - 예: `NFT ID 1`이 `address B`에게 전송 권한을 부여하면, `_approvals[1] = address B`
4. **`isApprovedForAll`**:
    - 특정 주소가 모든 NFT에 대해 승인되었는지 여부를 저장
    - 예: `address A`가 `address B`에게 모든 NFT의 권한을 부여하면, `isApprovedForAll[address A][address B] = true`

### supportsInterface 함수

```solidity
function supportsInterface(bytes4 interfaceId)
        external
        pure
        returns (bool)
    {
        return interfaceId == type(IERC721).interfaceId
            || interfaceId == type(IERC165).interfaceId;
    }
```

컨트랙트가 특정 인터페이스를 지원하는지 확인

(ERC721 컨트랙트는 반드시 ERC165 표준을 준수해야 하므로 구현된 함수이다.)

입력받은 `interfaceId`가 `IERC721` 또는 `IERC165`의 인터페이스 ID와 일치하면 `true`를 반환

### ownerOf 함수

```solidity

    function ownerOf(uint256 id) external view returns (address owner) {
        owner = _ownerOf[id];
        require(owner != address(0), "token doesn't exist");
    }
```

`_ownerOf` 자료에서 해당 NFT ID의 소유자를 조회

### balanceOf 함수

```solidity
 function balanceOf(address owner) external view returns (uint256) {
        require(owner != address(0), "owner = zero address");
        return _balanceOf[owner];
    }
```

특정 주소가 소유한 NFT 개수를 반환 (`_balanceOf`에서 해당 주소의 NFT 개수를 반환)

### setApprovalForAll 함수

```solidity
 function setApprovalForAll(address operator, bool approved) external {
        isApprovedForAll[msg.sender][operator] = approved;
        emit ApprovalForAll(msg.sender, operator, approved);
    }

```

`msg.sender`가 특정 주소 `operator`에게 모든 NFT에 대한 권한을 부여하거나 해제

`ApprovalForAll` 이벤트를 발생시킨다. 

### approve 함수

```solidity
function approve(address spender, uint256 id) external {
        address owner = _ownerOf[id];
        require(
            msg.sender == owner || isApprovedForAll[owner][msg.sender],
            "not authorized"
        );

        _approvals[id] = spender;

        emit Approval(owner, spender, id);
    }
```

`msg.sender == owner` 호출자가 해당 NFT의 소유자이거나 
`isApprovedForAll[owner][msg.sender]` 모든 권한을 부여받은 주소인지 확인

`_approvals`에 해당 NFT ID에 대해 승인된 주소를 저장

`Approval` 이벤트를 발생

### getApproved 함수

```solidity
function getApproved(uint256 id) external view returns (address) {
        require(_ownerOf[id] != address(0), "token doesn't exist");
        return _approvals[id];
    }
```

`_ownerOf[id] != address(0)` 해당 NFT가 존재하지 않으면 오류를 발생

`_approvals`에서 해당 NFT ID에 대해 승인된 주소를 반환

### _isApprovedOrOwner 함수

```solidity
function _isApprovedOrOwner(address owner, address spender, uint256 id)
        internal
        view
        returns (bool)
    {
        return (
            spender == owner || isApprovedForAll[owner][spender]
                || spender == _approvals[id]
        );
    }
```

`spender == owner` : 호출자가 소유자인지 체크

`isApprovedForAll[owner][spender]` : 호출자가 모든 NFT에 대한 승인을 받았는지 체크

`spender == _approvals[id]` : 호출자가 해당 NFT에서만이라도 승인된 주소인지

### tranferFrom 함수

```solidity
function transferFrom(address from, address to, uint256 id) public {
        require(from == _ownerOf[id], "from != owner");
        require(to != address(0), "transfer to zero address");

        require(_isApprovedOrOwner(from, msg.sender, id), "not authorized");

        _balanceOf[from]--;
        _balanceOf[to]++;
        _ownerOf[id] = to;

        delete _approvals[id];

        emit Transfer(from, to, id);
    }
```

require문 → 호출자가 해당 NFT의 소유자 또는 그 NFT에 대해 승인된 주소인지 확인

`_balanceOf` , `_ownerOf` 조정

**승인 정보를 삭제**

`Transfer` 이벤트를 발생

### safeTransferFrom 함수

```solidity
 function safeTransferFrom(address from, address to, uint256 id) external {
        transferFrom(from, to, id);

        require(
            to.code.length == 0
                || IERC721Receiver(to).onERC721Received(msg.sender, from, id, "")
                    == IERC721Receiver.onERC721Received.selector,
            "unsafe recipient"
        );
    }
```

`transferFrom`을 호출하여 기본 전송 작업을 수행 

require 문

**`to.code.length == 0`** : ****수신자 주소가 EOA인지 확인

**`IERC721Receiver(to).onERC721Received(...)`** : 수신자가 CA였다면, 해당 컨트랙트가 `IERC721Receiver` 인터페이스를 구현했는지 확인
이 함수는 호출되었을 때, 정확히 **`IERC721Receiver.onERC721Received.selector`** 값을 반환해야함으로 이를 만족하는지 검사하는 것.

둘중 하나라도 실패하면 revert됨.(트랜잭션 되돌려짐)

### _mint 함수

```solidity
function _mint(address to, uint256 id) internal {
        require(to != address(0), "mint to zero address");
        require(_ownerOf[id] == address(0), "already minted");

        _balanceOf[to]++;
        _ownerOf[id] = to;

        emit Transfer(address(0), to, id);
    }
```

새로운 NFT 생성하는 함수

`to != address(0)` 대상 주소가 0x0이 아니어야함

`_ownerOf[id] == address(0)` 이미 해당 id의 소유자가 존재하는 지 확인 (존재한다면, 이미 사용 중인 id임으로 다른 id로 발행해야함.)

`_balanceOf` 및 `_ownerOf`를 업데이트

`Transfer` 이벤트를 발생

### _burn 함수

```solidity
    function _burn(uint256 id) internal {
        address owner = _ownerOf[id];
        require(owner != address(0), "not minted");

        _balanceOf[owner] -= 1;

        delete _ownerOf[id];
        delete _approvals[id];

        emit Transfer(owner, address(0), id);
    }
}
```

기존 NFT를 소각하는 함수

`owner != address(0)` 소유자가 없다 → 애초에 존재하지 않는 NFT

`_balanceOf[owner] -= 1` balanceOf 조정

`delete _ownerOf[id];
delete _approvals[id];` 소유자, 승인 정보 삭제

`Transfer` 이벤트를 발생