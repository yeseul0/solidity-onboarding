# NFT English Auction

영국식 경매 **English Auction** 을 블록체인 위에서 구현할 수도 있다. 경매는 판매자가 NFT를 경매에 올리고, 참가자들이 점점 높은 금액으로 입찰하며 가장 높은 금액을 제시한 사람이 NFT를 구매하는 방식으로 진행된다. 

### 전체코드
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

interface IERC721 {
    function safeTransferFrom(address from, address to, uint256 tokenId)
        external;
    function transferFrom(address, address, uint256) external;
}

contract EnglishAuction {
    event Start();
    event Bid(address indexed sender, uint256 amount);
    event Withdraw(address indexed bidder, uint256 amount);
    event End(address winner, uint256 amount);

    IERC721 public nft;
    uint256 public nftId;

    address payable public seller;
    uint256 public endAt;
    bool public started;
    bool public ended;

    address public highestBidder;
    uint256 public highestBid;
    mapping(address => uint256) public bids;

    constructor(address _nft, uint256 _nftId, uint256 _startingBid) {
        nft = IERC721(_nft);
        nftId = _nftId;

        seller = payable(msg.sender);
        highestBid = _startingBid;
    }

    function start() external {
        require(!started, "started");
        require(msg.sender == seller, "not seller");

        nft.transferFrom(msg.sender, address(this), nftId);
        started = true;
        endAt = block.timestamp + 7 days;

        emit Start();
    }

    function bid() external payable {
        require(started, "not started");
        require(block.timestamp < endAt, "ended");
        require(msg.value > highestBid, "value < highest");

        if (highestBidder != address(0)) {
            bids[highestBidder] += highestBid;
        }

        highestBidder = msg.sender;
        highestBid = msg.value;

        emit Bid(msg.sender, msg.value);
    }

    function withdraw() external {
        uint256 bal = bids[msg.sender];
        bids[msg.sender] = 0;
        payable(msg.sender).transfer(bal);

        emit Withdraw(msg.sender, bal);
    }

    function end() external {
        require(started, "not started");
        require(block.timestamp >= endAt, "not ended");
        require(!ended, "ended");

        ended = true;
        if (highestBidder != address(0)) {
            nft.safeTransferFrom(address(this), highestBidder, nftId);
            seller.transfer(highestBid);
        } else {
            nft.safeTransferFrom(address(this), seller, nftId);
        }

        emit End(highestBidder, highestBid);
    }
}
```
---

### 상태변수
1. **NFT 관련 변수**:
    - `IERC721 public nft`: 경매에 올릴 NFT를 관리하는 인터페이스.
    - `uint256 public nftId`: 경매에 올린 NFT의 ID.
2. **경매 관련 변수**:
    - `address payable public seller`: NFT의 판매자.
    - `uint256 public endAt`: 경매 종료 시간.
    - `bool public started`: 경매 시작 여부.
    - `bool public ended`: 경매 종료 여부.
3. **입찰 관련 변수**:
    - `address public highestBidder`: 현재 가장 높은 금액을 입찰한 사람.
    - `uint256 public highestBid`: 현재 가장 높은 입찰 금액.
    - `mapping(address => uint256) public bids`: 입찰자들이 이전에 입찰한 금액을 저장하는 매핑.

### 생성자
```solidity
constructor(address _nft, uint256 _nftId, uint256 _startingBid) {
        nft = IERC721(_nft);
        nftId = _nftId;

        seller = payable(msg.sender);
        highestBid = _startingBid;
    }
```
경매를 생성할 때 NFT 주소, NFT id, 초기 입찰 금액을 설정한다.  
`seller = payable(msg.sender)` 판매자는 컨트랙트를 생성한 사람으로 설정 (컨트랙트 하나가 경매 하나)

### 함수 `start`
```solidity
function start() external {
        require(!started, "started");
        require(msg.sender == seller, "not seller");

        nft.transferFrom(msg.sender, address(this), nftId);
        started = true;
        endAt = block.timestamp + 7 days;

        emit Start();
    }
```
`nft.transferFrom(msg.sender, address(this), nftId)`  
: 판매자가 NFT를 컨트랙트로 전송하며 경매를 시작한다.   
`endAt = block.timestamp + 7 days`  
: 7일간 경매

### 함수 `bid` 
```solidity
function bid() external payable {
        require(started, "not started");
        require(block.timestamp < endAt, "ended");
        require(msg.value > highestBid, "value < highest");

        if (highestBidder != address(0)) {
            bids[highestBidder] += highestBid;
        }

        highestBidder = msg.sender;
        highestBid = msg.value;

        emit Bid(msg.sender, msg.value);
    }
```
경매가 끝나지 않은 상태에서 참가자가 입찰할 수 있다.  
`require(msg.value > highestBid, "value < highest")`  
: 입찰 금액은 현재 최고 입찰 금액보다 높아야 한다. 

`bids[highestBidder] += highestBid`  
: 이전 최고 입찰자의 금액은 `bids` 맵핑에 저장된다.

`highestBidder = msg.sender` , `highestBid = msg.value`  
: 새로운 최고금액 입찰자의 주소와 입찰 금액을 업데이트 한다. 

### 함수 `withdraw` 
```solidity
function withdraw() external {
        uint256 bal = bids[msg.sender];
        bids[msg.sender] = 0;
        payable(msg.sender).transfer(bal);

        emit Withdraw(msg.sender, bal);
    }
```
경매 입찰에 참여했던 사람들은 경매 종료 후 입찰 금액을 반환 받는다.  
`bids` 맵핑 업데이트 

### 함수 `end`
```solidity
function end() external {
        require(started, "not started");
        require(block.timestamp >= endAt, "not ended");
        require(!ended, "ended");

        ended = true;
        if (highestBidder != address(0)) {
            nft.safeTransferFrom(address(this), highestBidder, nftId);
            seller.transfer(highestBid);
        } else {
            nft.safeTransferFrom(address(this), seller, nftId);
        }

        emit End(highestBidder, highestBid);
    }
```
경매 종료 시간이 지나고 판매자가 경매를 종료한다.  
- 최고 입찰자가 있을 경우 (`highestBidder != address(0)`)  
: NFT를 최고 입찰자에게 전송 & 판매자에게 최고 입찰 금액 전송
- 최고 입찰자가 없을 경우 (`else`)  
: NFT를 판매자에게 반환