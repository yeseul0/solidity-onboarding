# CrowdFunding

크라우드 펀딩은 많은 사람들이 소액의 돈을 모아 특정 프로젝트, 아이디어, 제품 개발, 또는 사회적 목적을 지원하는 방식이다. 누구나 자신의 아이디어를 소개하고, 필요한 자금을 모으기 위해 캠페인을 시작할 수 있다. (기부자들은 프로젝트가 성공하면 혜택을 받거나, 단순히 프로젝트를 지원하는 데 만족감)
블록체인 기반 크라우드 펀딩 플랫폼을 구현하면 스마트 컨트랙트를 통해 자금의 관리와 기부금 반환 같은 과정을 자동화할 수 있으며, 기부자들은 기부한 자금이 목표 달성 여부에 따라 안전하게 관리된다는 신뢰를 얻을 수 있다.

아래 코드 예시는 사용자가 Token을 캠페인에 pledge(기부)하며, 목표 금액에 도달하면 캠페인 주최자가 자금을 인출할 수 있도록 한다. 목표 금액에 도달하지 못한 경우, 사용자는 자신의 기부금을 도로 환불 받을 수 있게끔 한 예시이다. 

### 전체코드
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

interface IERC20 {
    function transfer(address, uint256) external returns (bool); // ERC20 토큰 전송 함수
    function transferFrom(address, address, uint256) external returns (bool); // ERC20 토큰을 특정 주소에서 전송하는 함수
}

contract CrowdFund {
    // 이벤트 선언
    event Launch(
        uint256 id,
        address indexed creator,
        uint256 goal,
        uint32 startAt,
        uint32 endAt
    );
    event Cancel(uint256 id); // 캠페인 취소 이벤트
    event Pledge(uint256 indexed id, address indexed caller, uint256 amount); // 기부 이벤트
    event Unpledge(uint256 indexed id, address indexed caller, uint256 amount); // 기부 취소 이벤트
    event Claim(uint256 id); // 캠페인 성공 후 자금 인출 이벤트
    event Refund(uint256 id, address indexed caller, uint256 amount); // 목표 미달성 시 환불 이벤트

    // 캠페인 구조체 정의
    struct Campaign {
        address creator; // 캠페인 생성자
        uint256 goal; // 목표 금액
        uint256 pledged; // 현재까지 기부된 금액
        uint32 startAt; // 캠페인 시작 시간
        uint32 endAt; // 캠페인 종료 시간
        bool claimed; // 캠페인 성공 후 자금이 인출되었는지 여부
    }

    IERC20 public immutable token; // 사용할 ERC20 토큰
    uint256 public count; // 캠페인 수
    mapping(uint256 => Campaign) public campaigns; // 캠페인 ID에서 캠페인 정보로의 매핑
    mapping(uint256 => mapping(address => uint256)) public pledgedAmount; // 캠페인 ID와 사용자 주소에서 기부 금액으로의 매핑

    // 생성자 함수: ERC20 토큰의 주소를 초기화
    constructor(address _token) {
        token = IERC20(_token);
    }

    // 새로운 캠페인을 시작하는 함수
    function launch(uint256 _goal, uint32 _startAt, uint32 _endAt) external {
        require(_startAt >= block.timestamp, "start at < now"); // 시작 시간이 현재 시간보다 늦어야 함
        require(_endAt >= _startAt, "end at < start at"); // 종료 시간이 시작 시간보다 늦어야 함
        require(_endAt <= block.timestamp + 90 days, "end at > max duration"); // 캠페인 기간이 최대 90일을 초과할 수 없음

        count += 1; // 캠페인 수 증가
        campaigns[count] = Campaign({
            creator: msg.sender,
            goal: _goal,
            pledged: 0,
            startAt: _startAt,
            endAt: _endAt,
            claimed: false
        });

        emit Launch(count, msg.sender, _goal, _startAt, _endAt); // 캠페인 시작 이벤트 발생
    }

    // 캠페인을 취소하는 함수
    function cancel(uint256 _id) external {
        Campaign memory campaign = campaigns[_id];
        require(campaign.creator == msg.sender, "not creator"); // 캠페인 생성자만 취소 가능
        require(block.timestamp < campaign.startAt, "started"); // 캠페인이 시작되기 전에만 취소 가능

        delete campaigns[_id]; // 캠페인 정보 삭제
        emit Cancel(_id); // 캠페인 취소 이벤트 발생
    }

    // 캠페인에 기부하는 함수
    function pledge(uint256 _id, uint256 _amount) external {
        Campaign storage campaign = campaigns[_id];
        require(block.timestamp >= campaign.startAt, "not started"); // 캠페인이 시작되었는지 확인
        require(block.timestamp <= campaign.endAt, "ended"); // 캠페인이 종료되지 않았는지 확인

        campaign.pledged += _amount; // 기부 금액 추가
        pledgedAmount[_id][msg.sender] += _amount; // 기부자의 기부 금액 업데이트
        token.transferFrom(msg.sender, address(this), _amount); // 기부 금액을 컨트랙트로 전송

        emit Pledge(_id, msg.sender, _amount); // 기부 이벤트 발생
    }

    // 캠페인에서 기부를 취소하는 함수
    function unpledge(uint256 _id, uint256 _amount) external {
        Campaign storage campaign = campaigns[_id];
        require(block.timestamp <= campaign.endAt, "ended"); // 캠페인이 종료되지 않았는지 확인

        campaign.pledged -= _amount; // 기부 금액 차감
        pledgedAmount[_id][msg.sender] -= _amount; // 기부자의 기부 금액 업데이트
        token.transfer(msg.sender, _amount); // 기부 금액 반환

        emit Unpledge(_id, msg.sender, _amount); // 기부 취소 이벤트 발생
    }

    // 캠페인 목표 달성 시 자금을 인출하는 함수
    function claim(uint256 _id) external {
        Campaign storage campaign = campaigns[_id];
        require(campaign.creator == msg.sender, "not creator"); // 캠페인 생성자만 인출 가능
        require(block.timestamp > campaign.endAt, "not ended"); // 캠페인이 종료되었는지 확인
        require(campaign.pledged >= campaign.goal, "pledged < goal"); // 목표 금액 달성 여부 확인
        require(!campaign.claimed, "claimed"); // 이미 인출되었는지 확인

        campaign.claimed = true; // 인출 상태로 변경
        token.transfer(campaign.creator, campaign.pledged); // 기부 금액 인출

        emit Claim(_id); // 자금 인출 이벤트 발생
    }

    // 캠페인이 목표 금액을 달성하지 못한 경우 환불하는 함수
    function refund(uint256 _id) external {
        Campaign memory campaign = campaigns[_id];
        require(block.timestamp > campaign.endAt, "not ended"); // 캠페인이 종료되었는지 확인
        require(campaign.pledged < campaign.goal, "pledged >= goal"); // 목표 금액 미달성 여부 확인

        uint256 bal = pledgedAmount[_id][msg.sender]; // 기부자의 기부 금액 저장
        pledgedAmount[_id][msg.sender] = 0; // 기부 금액 초기화
        token.transfer(msg.sender, bal); // 기부 금액 반환

        emit Refund(_id, msg.sender, bal); // 환불 이벤트 발생
    }
}
```

### 주요 데이터 구조
- **`Campaign` 구조체**:
    - 캠페인 정보를 저장하는 구조체
    - **필드**:
        - `creator`: 캠페인을 생성한 사용자 주소.
        - `goal`: 캠페인의 목표 금액.
        - `pledged`: 현재까지 기부된 금액.
        - `startAt`: 캠페인의 시작 시간 (Unix timestamp).
        - `endAt`: 캠페인의 종료 시간 (Unix timestamp).
        - `claimed`: 캠페인 성공 후 자금이 인출되었는지 여부.
- **`mapping`**:
    - `campaigns`: 캠페인 ID를 `Campaign` 구조체와 매핑.
    - `pledgedAmount`: 캠페인 ID와 사용자 주소를 기부 금액과 매핑.

### 주요 이벤트
- **`Launch`**: 캠페인이 생성될 때 발생.
- **`Cancel`**: 캠페인이 취소될 때 발생.
- **`Pledge`**: 사용자가 캠페인에 기부할 때 발생.
- **`Unpledge`**: 사용자가 기부를 취소할 때 발생.
- **`Claim`**: 캠페인 목표 달성 후 자금을 인출할 때 발생.
- **`Refund`**: 캠페인이 목표를 달성하지 못했을 때 사용자가 환불받을 때 발생.

### 함수 `constructor`
```solidity
constructor(address _token) {
    token = IERC20(_token);
}
```
이 컨트랙트가 관리할 펀딩들에서 사용할 ERC 토큰 주소 초기화 


### 함수 `launch`
```solidity
function launch(uint256 _goal, uint32 _startAt, uint32 _endAt) external {
        require(_startAt >= block.timestamp, "start at < now"); // 시작 시간이 현재 시간보다 늦어야 함
        require(_endAt >= _startAt, "end at < start at"); // 종료 시간이 시작 시간보다 늦어야 함
        require(_endAt <= block.timestamp + 90 days, "end at > max duration"); // 캠페인 기간이 최대 90일을 초과할 수 없음

        count += 1; // 캠페인 수 증가
        campaigns[count] = Campaign({
            creator: msg.sender,
            goal: _goal,
            pledged: 0,
            startAt: _startAt,
            endAt: _endAt,
            claimed: false
        });

        emit Launch(count, msg.sender, _goal, _startAt, _endAt); // 캠페인 시작 이벤트 발생
    }
```
새로운 캠페인 등록하는 함수이다.   
`_goal` : 캠페인 목표 금액 
`_startAt` : 캠페인 시작 시간 
`_endAt` : 캠페인 종료 시간 
을 인자로 받아서 새로운 캠페인 정보를 `campaigns` 매핑에 추가한다. 

 ### 함수 `cancel` 
 ```solidity
 function cancel(uint256 _id) external {
        Campaign memory campaign = campaigns[_id];
        require(campaign.creator == msg.sender, "not creator"); // 캠페인 생성자만 취소 가능
        require(block.timestamp < campaign.startAt, "started"); // 캠페인이 시작되기 전에만 취소 가능

        delete campaigns[_id]; // 캠페인 정보 삭제
        emit Cancel(_id); // 캠페인 취소 이벤트 발생
    }
```

이 컨트랙트에 등록된 캠페인이 아직 모금 시작 전이라면, 이 함수를 통해 취소할 수 있다. 
취소할 캠페인의 `_id`만 인자로 받아서 campaigns 매핑에서 delete 한다. 


### 함수 `pledge`
```solidity
function pledge(uint256 _id, uint256 _amount) external {
        Campaign storage campaign = campaigns[_id];
        require(block.timestamp >= campaign.startAt, "not started"); // 캠페인이 시작되었는지 확인
        require(block.timestamp <= campaign.endAt, "ended"); // 캠페인이 종료되지 않았는지 확인

        campaign.pledged += _amount; // 기부 금액 추가
        pledgedAmount[_id][msg.sender] += _amount; // 기부자의 기부 금액 업데이트
        token.transferFrom(msg.sender, address(this), _amount); // 기부 금액을 컨트랙트로 전송

        emit Pledge(_id, msg.sender, _amount); // 기부 이벤트 발생
    }
```
`_id`의 ID를 가진 캠페인에 `_amount`만큼 기부하는 함수이다. 
`campaign` 구조체의 `pledged` 필드값을 조정하여 해당 컨트랙트의 총 기부 금액을 추가한다.  
하나의 캠페인에 대해서도 사용자별로 얼마나 자금을 넣었는지를 기록하기 위해서 `pledgedAmount` 매핑 (캠페인 ID -> 사용자 주소 -> 펀딩 양)을 업데이트 한다. 

### 함수 `unpledge`
```solidity
function unpledge(uint256 _id, uint256 _amount) external {
        Campaign storage campaign = campaigns[_id];
        require(block.timestamp <= campaign.endAt, "ended"); // 캠페인이 종료되지 않았는지 확인

        campaign.pledged -= _amount; // 기부 금액 차감
        pledgedAmount[_id][msg.sender] -= _amount; // 기부자의 기부 금액 업데이트
        token.transfer(msg.sender, _amount); // 기부 금액 반환

        emit Unpledge(_id, msg.sender, _amount); // 기부 취소 이벤트 발생
    }
```
캠페인에 펀딩했던 금액을 취소하는 함수이다.  
펀딩을 취소할 캠페인의 `_id`  
취소할 ERC20 토큰의 양 `_amount`을 인자로 입력받는다.  

`campaign` 구조체의 `pledged` 필드값을 조정하여 해당 컨트랙트의 총 기부 금액을 차감한다.  
`pledgedAmount` 매핑 또한 금액 감소 

### 함수 `claim`
```solidity
function claim(uint256 _id) external {
        Campaign storage campaign = campaigns[_id];
        require(campaign.creator == msg.sender, "not creator"); // 캠페인 생성자만 인출 가능
        require(block.timestamp > campaign.endAt, "not ended"); // 캠페인이 종료되었는지 확인
        require(campaign.pledged >= campaign.goal, "pledged < goal"); // 목표 금액 달성 여부 확인
        require(!campaign.claimed, "claimed"); // 이미 인출되었는지 확인

        campaign.claimed = true; // 인출 상태로 변경
        token.transfer(campaign.creator, campaign.pledged); // 기부 금액 인출

        emit Claim(_id); // 자금 인출 이벤트 발생
    }
```
종료된 캠페인에 대해서 목표금액을 달성했을 때, 자금을 인출하는 함수이다.  
인출할 캠페인의 `_id`를 인자로 받아 캠페인 생성자인지, 캠페인이 종료되었는지, 목표금액이 달성 됐는지, 이미 인출을 했었는지를 검사한다.  
모인 자금 `campaign.pledged` 만큼 캠페인 생성자에게 trasfer 함 

### 함수 `refund`
```solidity
function refund(uint256 _id) external {
        Campaign memory campaign = campaigns[_id];
        require(block.timestamp > campaign.endAt, "not ended"); // 캠페인이 종료되었는지 확인
        require(campaign.pledged < campaign.goal, "pledged >= goal"); // 목표 금액 미달성 여부 확인

        uint256 bal = pledgedAmount[_id][msg.sender]; // 기부자의 기부 금액 저장
        pledgedAmount[_id][msg.sender] = 0; // 기부 금액 초기화
        token.transfer(msg.sender, bal); // 기부 금액 반환

        emit Refund(_id, msg.sender, bal); // 환불 이벤트 발생
    }
```
캠페인이 목표 금액을 달성하지 못했을 때 기부자들에게 기부금이 돌아가는 함수이다.  
캠페인이 종료되었고, 모인 금액이 목표치보다 적을 경우에 `pledgedAmount` 자료를 참고하여 사용자가 펀딩했던만큼의 토큰을 다시 사용자에게 transfer 해준다.   